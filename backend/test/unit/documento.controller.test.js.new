import { jest } from '@jest/globals';
import DocumentoService from '../../src/services/documento.service.js';
import { DocumentoDTO } from '../../src/dto/index.js';
import * as documentoController from '../../src/controllers/documento.controller.js';

const mockServiceInstance = {
    verificarPermissao: jest.fn(),
    adicionar: jest.fn(),
    listar: jest.fn(),
    obter: jest.fn(),
    atualizar: jest.fn(),
    excluir: jest.fn()
};

jest.mock('../../src/services/documento.service.js', () => ({
    default: jest.fn().mockImplementation(() => mockServiceInstance)
}));

jest.mock('../../src/dto/index.js', () => ({
    DocumentoDTO: {
        from: jest.fn(),
        list: jest.fn()
    }
}));

describe('DocumentoController', () => {
    let mockReq;
    let mockRes;
    let mockNext;

    beforeEach(() => {
        mockReq = {
            params: {},
            body: {},
            usuario: { id: 1 }
        };
        mockRes = {
            status: jest.fn().mockReturnThis(),
            json: jest.fn(),
            download: jest.fn(),
            end: jest.fn()
        };
        mockNext = jest.fn();

        // Reset all mocks
        jest.clearAllMocks();
    });

    describe('adicionarDocumento', () => {
        beforeEach(() => {
            mockReq.file = {
                originalname: 'test.pdf',
                path: '/uploads/test.pdf'
            };
            mockReq.params.alunoId = '1';
            mockReq.body = { descricao: 'Test Doc' };
        });

        it('retorna 400 quando não há arquivo', async () => {
            mockServiceInstance.adicionar.mockResolvedValue({
                error: true,
                status: 400,
                message: 'Nenhum arquivo foi enviado'
            });

            await documentoController.adicionarDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(400);
        });

        it('retorna 201 quando documento é criado', async () => {
            const mockDocumento = { id: 1, nome: 'test.pdf' };
            const mockDTO = { id: 1, nome: 'test.pdf', downloadUrl: '/download/1' };

            mockServiceInstance.adicionar.mockResolvedValue({ documento: mockDocumento });
            DocumentoDTO.from.mockReturnValue(mockDTO);

            await documentoController.adicionarDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(201);
            expect(mockRes.json).toHaveBeenCalledWith(mockDTO);
        });

        it('chama next com erro em caso de exceção', async () => {
            const error = new Error('Test error');
            mockServiceInstance.adicionar.mockRejectedValue(error);

            await documentoController.adicionarDocumento(mockReq, mockRes, mockNext);
            expect(mockNext).toHaveBeenCalledWith(error);
        });
    });

    describe('listarDocumentos', () => {
        beforeEach(() => {
            mockReq.params.alunoId = '1';
        });

        it('retorna 403 quando usuário não tem permissão', async () => {
            mockServiceInstance.verificarPermissao.mockResolvedValue(false);

            await documentoController.listarDocumentos(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(403);
        });

        it('retorna lista de documentos com sucesso', async () => {
            const mockDocumentos = [{ id: 1 }, { id: 2 }];
            const mockDTOs = mockDocumentos.map(d => ({ ...d, downloadUrl: `/download/${d.id}` }));

            mockServiceInstance.verificarPermissao.mockResolvedValue(true);
            mockServiceInstance.listar.mockResolvedValue({ documentos: mockDocumentos });
            DocumentoDTO.from.mockImplementation((doc) => ({ ...doc, downloadUrl: `/download/${doc.id}` }));

            await documentoController.listarDocumentos(mockReq, mockRes, mockNext);
            expect(mockRes.json).toHaveBeenCalledWith({ documentos: mockDTOs });
        });
    });

    describe('obterDocumento', () => {
        beforeEach(() => {
            mockReq.params = { alunoId: '1', documentoId: '1' };
        });

        it('retorna 403 quando usuário não tem permissão', async () => {
            mockServiceInstance.verificarPermissao.mockResolvedValue(false);

            await documentoController.obterDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(403);
        });

        it('inicia download quando documento existe', async () => {
            const mockDocumento = { caminhoArquivo: '/test.pdf', nome: 'test.pdf' };

            mockServiceInstance.verificarPermissao.mockResolvedValue(true);
            mockServiceInstance.obter.mockResolvedValue({ documento: mockDocumento });

            await documentoController.obterDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.download).toHaveBeenCalledWith(mockDocumento.caminhoArquivo, mockDocumento.nome);
        });
    });

    describe('atualizarDocumento', () => {
        beforeEach(() => {
            mockReq.params = { alunoId: '1', documentoId: '1' };
            mockReq.body = { nome: 'updated.pdf' };
        });

        it('retorna 403 quando usuário não tem permissão', async () => {
            mockServiceInstance.verificarPermissao.mockResolvedValue(false);

            await documentoController.atualizarDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(403);
        });

        it('atualiza documento com sucesso', async () => {
            const mockDocumento = { id: 1, nome: 'updated.pdf' };
            const mockDTO = { ...mockDocumento, downloadUrl: '/download/1' };

            mockServiceInstance.verificarPermissao.mockResolvedValue(true);
            mockServiceInstance.atualizar.mockResolvedValue({ documento: mockDocumento });
            DocumentoDTO.from.mockReturnValue(mockDTO);

            await documentoController.atualizarDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.json).toHaveBeenCalledWith(mockDTO);
        });
    });

    describe('excluirDocumento', () => {
        beforeEach(() => {
            mockReq.params = { alunoId: '1', documentoId: '1' };
        });

        it('retorna 403 quando usuário não tem permissão', async () => {
            mockServiceInstance.verificarPermissao.mockResolvedValue(false);

            await documentoController.excluirDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(403);
        });

        it('retorna 204 quando documento é excluído', async () => {
            mockServiceInstance.verificarPermissao.mockResolvedValue(true);
            mockServiceInstance.excluir.mockResolvedValue({ success: true });

            await documentoController.excluirDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(204);
            expect(mockRes.end).toHaveBeenCalled();
        });
    });

    describe('downloadDocumento', () => {
        beforeEach(() => {
            mockReq.params = { alunoId: '1', documentoId: '1' };
        });

        it('retorna 403 quando usuário não tem permissão', async () => {
            mockServiceInstance.verificarPermissao.mockResolvedValue(false);

            await documentoController.downloadDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.status).toHaveBeenCalledWith(403);
        });

        it('inicia download quando documento existe', async () => {
            const mockDocumento = { caminhoArquivo: '/test.pdf', nome: 'test.pdf' };

            mockServiceInstance.verificarPermissao.mockResolvedValue(true);
            mockServiceInstance.obter.mockResolvedValue({ documento: mockDocumento });

            await documentoController.downloadDocumento(mockReq, mockRes, mockNext);
            expect(mockRes.download).toHaveBeenCalledWith(mockDocumento.caminhoArquivo, mockDocumento.nome, expect.any(Function));
        });
    });
});